<?php
namespace com\boxalino\p13n\api\thrift;

/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


/**
 * Used for date facets
 */
final class DateRangeGap {
  const SECOND = 1;
  const MINUTE = 2;
  const HOUR = 3;
  const DAY = 4;
  const WEEK = 5;
  const MONTH = 6;
  const YEAR = 7;
  const DECADE = 8;
  const CENTURY = 9;
  static public $__names = array(
    1 => 'SECOND',
    2 => 'MINUTE',
    3 => 'HOUR',
    4 => 'DAY',
    5 => 'WEEK',
    6 => 'MONTH',
    7 => 'YEAR',
    8 => 'DECADE',
    9 => 'CENTURY',
  );
}

/**
 * Whether facets should be order by population descending or by collation
 */
final class FacetSortOrder {
  const POPULATION = 1;
  const COLLATION = 2;
  static public $__names = array(
    1 => 'POPULATION',
    2 => 'COLLATION',
  );
}

/**
 * Filter to be used in query. Note that type of generated filter depends on first non-null and non-empty value in order of preference. Values of lower priority are ignored:
 * stringValues!=null && simpleValues.size()>0 => simple match, prefix!=null => prefix match, hierarchy!=null && hierarchy.size()>0 => hierarchy filter, else range filter
 * 
 * <dl>
 * <dt>negative</dt>
 * <dd>whether the filter is negative (boolean NOT)</dd>
 * 
 * <dt>fieldName</dt>
 * <dd>field name to apply filter to</dd>
 * 
 * <dt>stringValues</dt>
 * <dd>values for simple match</dd>
 * 
 * <dt>prefix</dt>
 * <dd>prefix match</dd>
 * 
 * <dt>hierarchyId</dt>
 * <dd>hierarchy filter - when corresponding hierarchical field has encoded id</dd>
 * 
 * <dt>hierarchy</dt>
 * <dd>hierarchy filter - for example categories path in top-down order</dd>
 * 
 * <dt>rangeFrom</dt>
 * <dd>lower bound for range filter</dd>
 * 
 * <dt>rangeFromInclusive</dt>
 * <dd>whether the lower bound is inclusive</dd>
 * 
 * <dt>rangeTo</dt>
 * <dd>upper bound for range filter</dd>
 * 
 * <dt>rangeToInclusive</dt>
 * <dd>whether the upper bound is inclusive</dd>
 * </dl>
 */
class Filter {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $negative = null;
  /**
   * @var string
   */
  public $fieldName = null;
  /**
   * @var string[]
   */
  public $stringValues = null;
  /**
   * @var string
   */
  public $prefix = null;
  /**
   * @var string
   */
  public $hierarchyId = null;
  /**
   * @var string[]
   */
  public $hierarchy = null;
  /**
   * @var string
   */
  public $rangeFrom = null;
  /**
   * @var bool
   */
  public $rangeFromInclusive = null;
  /**
   * @var string
   */
  public $rangeTo = null;
  /**
   * @var bool
   */
  public $rangeToInclusive = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'negative',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 'fieldName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'stringValues',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        4 => array(
          'var' => 'prefix',
          'type' => TType::STRING,
          ),
        41 => array(
          'var' => 'hierarchyId',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'hierarchy',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        6 => array(
          'var' => 'rangeFrom',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'rangeFromInclusive',
          'type' => TType::BOOL,
          ),
        8 => array(
          'var' => 'rangeTo',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'rangeToInclusive',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['negative'])) {
        $this->negative = $vals['negative'];
      }
      if (isset($vals['fieldName'])) {
        $this->fieldName = $vals['fieldName'];
      }
      if (isset($vals['stringValues'])) {
        $this->stringValues = $vals['stringValues'];
      }
      if (isset($vals['prefix'])) {
        $this->prefix = $vals['prefix'];
      }
      if (isset($vals['hierarchyId'])) {
        $this->hierarchyId = $vals['hierarchyId'];
      }
      if (isset($vals['hierarchy'])) {
        $this->hierarchy = $vals['hierarchy'];
      }
      if (isset($vals['rangeFrom'])) {
        $this->rangeFrom = $vals['rangeFrom'];
      }
      if (isset($vals['rangeFromInclusive'])) {
        $this->rangeFromInclusive = $vals['rangeFromInclusive'];
      }
      if (isset($vals['rangeTo'])) {
        $this->rangeTo = $vals['rangeTo'];
      }
      if (isset($vals['rangeToInclusive'])) {
        $this->rangeToInclusive = $vals['rangeToInclusive'];
      }
    }
  }

  public function getName() {
    return 'Filter';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->negative);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fieldName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->stringValues = array();
            $_size0 = 0;
            $_etype3 = 0;
            $xfer += $input->readListBegin($_etype3, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $elem5 = null;
              $xfer += $input->readString($elem5);
              $this->stringValues []= $elem5;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->prefix);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 41:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hierarchyId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->hierarchy = array();
            $_size6 = 0;
            $_etype9 = 0;
            $xfer += $input->readListBegin($_etype9, $_size6);
            for ($_i10 = 0; $_i10 < $_size6; ++$_i10)
            {
              $elem11 = null;
              $xfer += $input->readString($elem11);
              $this->hierarchy []= $elem11;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->rangeFrom);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->rangeFromInclusive);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->rangeTo);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->rangeToInclusive);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Filter');
    if ($this->negative !== null) {
      $xfer += $output->writeFieldBegin('negative', TType::BOOL, 1);
      $xfer += $output->writeBool($this->negative);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fieldName !== null) {
      $xfer += $output->writeFieldBegin('fieldName', TType::STRING, 2);
      $xfer += $output->writeString($this->fieldName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->stringValues !== null) {
      if (!is_array($this->stringValues)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('stringValues', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRING, count($this->stringValues));
        {
          foreach ($this->stringValues as $iter12)
          {
            $xfer += $output->writeString($iter12);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->prefix !== null) {
      $xfer += $output->writeFieldBegin('prefix', TType::STRING, 4);
      $xfer += $output->writeString($this->prefix);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hierarchy !== null) {
      if (!is_array($this->hierarchy)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hierarchy', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRING, count($this->hierarchy));
        {
          foreach ($this->hierarchy as $iter13)
          {
            $xfer += $output->writeString($iter13);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rangeFrom !== null) {
      $xfer += $output->writeFieldBegin('rangeFrom', TType::STRING, 6);
      $xfer += $output->writeString($this->rangeFrom);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rangeFromInclusive !== null) {
      $xfer += $output->writeFieldBegin('rangeFromInclusive', TType::BOOL, 7);
      $xfer += $output->writeBool($this->rangeFromInclusive);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rangeTo !== null) {
      $xfer += $output->writeFieldBegin('rangeTo', TType::STRING, 8);
      $xfer += $output->writeString($this->rangeTo);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rangeToInclusive !== null) {
      $xfer += $output->writeFieldBegin('rangeToInclusive', TType::BOOL, 9);
      $xfer += $output->writeBool($this->rangeToInclusive);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hierarchyId !== null) {
      $xfer += $output->writeFieldBegin('hierarchyId', TType::STRING, 41);
      $xfer += $output->writeString($this->hierarchyId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * <dl>
 * <dt>stringValue</dt>
 * <dd>corresponding value of the facet</dd>
 * 
 * <dt>rangeFromInclusive</dt>
 * <dd>if range facets lower bound (inclusive)</dd>
 * 
 * <dt>rangeToExclusive</dt>
 * <dd>if range facets upper bound (inclusive)</dd>
 * 
 * <dt>hitCount</dt>
 * <dd>number of hits found</dd>
 * 
 * <dt>hierarchyId</dt>
 * <dd>id of hierarchy if corresponding field is hierarchical</dd>
 * 
 * <dt>hierarchy</dt>
 * <dd>hierarchy if corresponding field is hierarchical</dd>
 * 
 * <dt>selected</dt>
 * <dd>whether the facet value has been selected in corresponding FacetRequest</dd>
 * </dl>
 */
class FacetValue {
  static $_TSPEC;

  /**
   * @var string
   */
  public $stringValue = null;
  /**
   * @var string
   */
  public $rangeFromInclusive = null;
  /**
   * @var string
   */
  public $rangeToExclusive = null;
  /**
   * @var int
   */
  public $hitCount = null;
  /**
   * @var string
   */
  public $hierarchyId = null;
  /**
   * @var string[]
   */
  public $hierarchy = null;
  /**
   * @var bool
   */
  public $selected = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'stringValue',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'rangeFromInclusive',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'rangeToExclusive',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'hitCount',
          'type' => TType::I64,
          ),
        50 => array(
          'var' => 'hierarchyId',
          'type' => TType::STRING,
          ),
        60 => array(
          'var' => 'hierarchy',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        70 => array(
          'var' => 'selected',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['stringValue'])) {
        $this->stringValue = $vals['stringValue'];
      }
      if (isset($vals['rangeFromInclusive'])) {
        $this->rangeFromInclusive = $vals['rangeFromInclusive'];
      }
      if (isset($vals['rangeToExclusive'])) {
        $this->rangeToExclusive = $vals['rangeToExclusive'];
      }
      if (isset($vals['hitCount'])) {
        $this->hitCount = $vals['hitCount'];
      }
      if (isset($vals['hierarchyId'])) {
        $this->hierarchyId = $vals['hierarchyId'];
      }
      if (isset($vals['hierarchy'])) {
        $this->hierarchy = $vals['hierarchy'];
      }
      if (isset($vals['selected'])) {
        $this->selected = $vals['selected'];
      }
    }
  }

  public function getName() {
    return 'FacetValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->stringValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->rangeFromInclusive);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->rangeToExclusive);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->hitCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 50:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hierarchyId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 60:
          if ($ftype == TType::LST) {
            $this->hierarchy = array();
            $_size14 = 0;
            $_etype17 = 0;
            $xfer += $input->readListBegin($_etype17, $_size14);
            for ($_i18 = 0; $_i18 < $_size14; ++$_i18)
            {
              $elem19 = null;
              $xfer += $input->readString($elem19);
              $this->hierarchy []= $elem19;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 70:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->selected);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('FacetValue');
    if ($this->stringValue !== null) {
      $xfer += $output->writeFieldBegin('stringValue', TType::STRING, 1);
      $xfer += $output->writeString($this->stringValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rangeFromInclusive !== null) {
      $xfer += $output->writeFieldBegin('rangeFromInclusive', TType::STRING, 2);
      $xfer += $output->writeString($this->rangeFromInclusive);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rangeToExclusive !== null) {
      $xfer += $output->writeFieldBegin('rangeToExclusive', TType::STRING, 3);
      $xfer += $output->writeString($this->rangeToExclusive);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hitCount !== null) {
      $xfer += $output->writeFieldBegin('hitCount', TType::I64, 4);
      $xfer += $output->writeI64($this->hitCount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hierarchyId !== null) {
      $xfer += $output->writeFieldBegin('hierarchyId', TType::STRING, 50);
      $xfer += $output->writeString($this->hierarchyId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hierarchy !== null) {
      if (!is_array($this->hierarchy)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hierarchy', TType::LST, 60);
      {
        $output->writeListBegin(TType::STRING, count($this->hierarchy));
        {
          foreach ($this->hierarchy as $iter20)
          {
            $xfer += $output->writeString($iter20);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->selected !== null) {
      $xfer += $output->writeFieldBegin('selected', TType::BOOL, 70);
      $xfer += $output->writeBool($this->selected);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * <dl>
 * <dt>fieldName</dt>
 * <dd>name of the field to get facet for</dd>
 * 
 * <dt>numerical</dt>
 * <dd>whether the facet is numerical</dd>
 * 
 * <dt>range</dt>
 * <dd>whether the facet is range facet</dd>
 * 
 * <dt>maxCount</dt>
 * <dd>maximum number of facets to return by given order, -1 for all of them</dd>
 * 
 * <dt>minPopulation</dt>
 * <dd>minimum facet population to return</dd>
 * 
 * <dt>dateRangeGap</dt>
 * <dd>if the corresponding field is date then the gap to be used for facet</dd>
 * 
 * <dt>sortOrder</dt>
 * <dd>sort order</dd>
 * 
 * <dt>sortAscending</dt>
 * <dd>whether the sort should be done ascending</dd>
 * 
 * <dt>selectedValues</dt>
 * <dd>values selected from the facet.</dd>
 * <dd>Note that results will be filtered by these values, but the corresponding
 * FacetResponse is as if this filter was not applied</dd>
 * 
 * <dt>andSelectedValues</dt>
 * <dd>whether selectedValues should be considered in AND logic, meaning filter
 * out those that don't contain ALL selected values - default is OR - include
 * those contianing any of selectedValue</dd>
 * 
 * <dt>boundsOnly</dt>
 * <dd>only affects numeric range facets. will always return one FacetValue with rangeFromInclusive and rangeToExclusive
 * set according to the actual minimum and maximum value</dd>
 * </dl>
 */
class FacetRequest {
  static $_TSPEC;

  /**
   * @var string
   */
  public $fieldName = null;
  /**
   * @var bool
   */
  public $numerical = null;
  /**
   * @var bool
   */
  public $range = null;
  /**
   * @var int
   */
  public $maxCount = -1;
  /**
   * @var int
   */
  public $minPopulation = 1;
  /**
   * @var int
   */
  public $dateRangeGap = null;
  /**
   * @var int
   */
  public $sortOrder = null;
  /**
   * @var bool
   */
  public $sortAscending = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\FacetValue[]
   */
  public $selectedValues = null;
  /**
   * @var bool
   */
  public $andSelectedValues = false;
  /**
   * @var bool
   */
  public $boundsOnly = false;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fieldName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'numerical',
          'type' => TType::BOOL,
          ),
        3 => array(
          'var' => 'range',
          'type' => TType::BOOL,
          ),
        4 => array(
          'var' => 'maxCount',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'minPopulation',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'dateRangeGap',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'sortOrder',
          'type' => TType::I32,
          ),
        8 => array(
          'var' => 'sortAscending',
          'type' => TType::BOOL,
          ),
        90 => array(
          'var' => 'selectedValues',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\FacetValue',
            ),
          ),
        100 => array(
          'var' => 'andSelectedValues',
          'type' => TType::BOOL,
          ),
        110 => array(
          'var' => 'boundsOnly',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fieldName'])) {
        $this->fieldName = $vals['fieldName'];
      }
      if (isset($vals['numerical'])) {
        $this->numerical = $vals['numerical'];
      }
      if (isset($vals['range'])) {
        $this->range = $vals['range'];
      }
      if (isset($vals['maxCount'])) {
        $this->maxCount = $vals['maxCount'];
      }
      if (isset($vals['minPopulation'])) {
        $this->minPopulation = $vals['minPopulation'];
      }
      if (isset($vals['dateRangeGap'])) {
        $this->dateRangeGap = $vals['dateRangeGap'];
      }
      if (isset($vals['sortOrder'])) {
        $this->sortOrder = $vals['sortOrder'];
      }
      if (isset($vals['sortAscending'])) {
        $this->sortAscending = $vals['sortAscending'];
      }
      if (isset($vals['selectedValues'])) {
        $this->selectedValues = $vals['selectedValues'];
      }
      if (isset($vals['andSelectedValues'])) {
        $this->andSelectedValues = $vals['andSelectedValues'];
      }
      if (isset($vals['boundsOnly'])) {
        $this->boundsOnly = $vals['boundsOnly'];
      }
    }
  }

  public function getName() {
    return 'FacetRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fieldName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->numerical);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->range);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->maxCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->minPopulation);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->dateRangeGap);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->sortOrder);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->sortAscending);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 90:
          if ($ftype == TType::LST) {
            $this->selectedValues = array();
            $_size21 = 0;
            $_etype24 = 0;
            $xfer += $input->readListBegin($_etype24, $_size21);
            for ($_i25 = 0; $_i25 < $_size21; ++$_i25)
            {
              $elem26 = null;
              $elem26 = new \com\boxalino\p13n\api\thrift\FacetValue();
              $xfer += $elem26->read($input);
              $this->selectedValues []= $elem26;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 100:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->andSelectedValues);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 110:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->boundsOnly);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('FacetRequest');
    if ($this->fieldName !== null) {
      $xfer += $output->writeFieldBegin('fieldName', TType::STRING, 1);
      $xfer += $output->writeString($this->fieldName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->numerical !== null) {
      $xfer += $output->writeFieldBegin('numerical', TType::BOOL, 2);
      $xfer += $output->writeBool($this->numerical);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->range !== null) {
      $xfer += $output->writeFieldBegin('range', TType::BOOL, 3);
      $xfer += $output->writeBool($this->range);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxCount !== null) {
      $xfer += $output->writeFieldBegin('maxCount', TType::I32, 4);
      $xfer += $output->writeI32($this->maxCount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->minPopulation !== null) {
      $xfer += $output->writeFieldBegin('minPopulation', TType::I32, 5);
      $xfer += $output->writeI32($this->minPopulation);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dateRangeGap !== null) {
      $xfer += $output->writeFieldBegin('dateRangeGap', TType::I32, 6);
      $xfer += $output->writeI32($this->dateRangeGap);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sortOrder !== null) {
      $xfer += $output->writeFieldBegin('sortOrder', TType::I32, 7);
      $xfer += $output->writeI32($this->sortOrder);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sortAscending !== null) {
      $xfer += $output->writeFieldBegin('sortAscending', TType::BOOL, 8);
      $xfer += $output->writeBool($this->sortAscending);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->selectedValues !== null) {
      if (!is_array($this->selectedValues)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('selectedValues', TType::LST, 90);
      {
        $output->writeListBegin(TType::STRUCT, count($this->selectedValues));
        {
          foreach ($this->selectedValues as $iter27)
          {
            $xfer += $iter27->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->andSelectedValues !== null) {
      $xfer += $output->writeFieldBegin('andSelectedValues', TType::BOOL, 100);
      $xfer += $output->writeBool($this->andSelectedValues);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->boundsOnly !== null) {
      $xfer += $output->writeFieldBegin('boundsOnly', TType::BOOL, 110);
      $xfer += $output->writeBool($this->boundsOnly);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * field to be used for sorting
 */
class SortField {
  static $_TSPEC;

  /**
   * @var string
   */
  public $fieldName = null;
  /**
   * @var bool
   */
  public $reverse = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fieldName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'reverse',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fieldName'])) {
        $this->fieldName = $vals['fieldName'];
      }
      if (isset($vals['reverse'])) {
        $this->reverse = $vals['reverse'];
      }
    }
  }

  public function getName() {
    return 'SortField';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fieldName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->reverse);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SortField');
    if ($this->fieldName !== null) {
      $xfer += $output->writeFieldBegin('fieldName', TType::STRING, 1);
      $xfer += $output->writeString($this->fieldName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->reverse !== null) {
      $xfer += $output->writeFieldBegin('reverse', TType::BOOL, 2);
      $xfer += $output->writeBool($this->reverse);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * <dl>
 * <dt>indexId</dt>
 * <dd>indexId to be used for search</dd>
 * 
 * <dt>language</dt>
 * <dd>language for localization</dd>
 * 
 * <dt>queryText</dt>
 * <dd>main search query</dd>
 * 
 * <dt>filters</dt>
 * <dd>list of filters to apply</dd>
 * 
 * <dt>orFilters</dt>
 * <dd>whether boolean OR should be aplied to the given list of filters if false
 * boolean AND will be applied</dd>
 * 
 * <dt>facetRequests</dt>
 * <dd>list of facets to be returned</dd>
 * 
 * <dt>sortFields</dt>
 * <dd>optional list of sort fields for hardcoded sorting. If not given,
 * relevance sort order will be used</dd>
 * 
 * <dt>offset</dt>
 * <dd>from which hit to return result</dd>
 * 
 * <dt>hitCount</dt>
 * <dd>how many hits to return</dd>
 * 
 * <dt>returnFields</dt>
 * <dd>which index fields to be returned</dd>
 * 
 * <dt>groupBy</dt>
 * <dd>field name of the field to do grouping by</dd>
 * 
 * <dt>groupFacets</dt>
 * <dd>whether facets counts should contain number of groups</dd>
 * 
 * <dt>groupItemsCount</dt>
 * <dd>how many hits in each group to return</dd>
 * 
 * <dt>groupItemsSort</dt>
 * <dd>how to sort items within the group, default is score</dd>
 * 
 * <dt>groupItemsSortAscending</dt>
 * <dd>whether to sort items within the group ascending</dd>
 * 
 * <dt>hitsGroupsAsHits</dt>
 * <dd>if true, will return hitsGroups as hits in the response</dd>
 * </dl>
 */
class SimpleSearchQuery {
  static $_TSPEC;

  /**
   * @var string
   */
  public $indexId = null;
  /**
   * @var string
   */
  public $language = null;
  /**
   * @var string
   */
  public $queryText = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\Filter[]
   */
  public $filters = null;
  /**
   * @var bool
   */
  public $orFilters = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\FacetRequest[]
   */
  public $facetRequests = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\SortField[]
   */
  public $sortFields = null;
  /**
   * @var int
   */
  public $offset = null;
  /**
   * @var int
   */
  public $hitCount = null;
  /**
   * @var string[]
   */
  public $returnFields = null;
  /**
   * @var string
   */
  public $groupBy = null;
  /**
   * @var bool
   */
  public $groupFacets = true;
  /**
   * @var int
   */
  public $groupItemsCount = 1;
  /**
   * @var string
   */
  public $groupItemsSort = "score";
  /**
   * @var bool
   */
  public $groupItemsSortAscending = false;
  /**
   * @var bool
   */
  public $hitsGroupsAsHits = false;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'indexId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'language',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'queryText',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'filters',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\Filter',
            ),
          ),
        5 => array(
          'var' => 'orFilters',
          'type' => TType::BOOL,
          ),
        6 => array(
          'var' => 'facetRequests',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\FacetRequest',
            ),
          ),
        7 => array(
          'var' => 'sortFields',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\SortField',
            ),
          ),
        8 => array(
          'var' => 'offset',
          'type' => TType::I64,
          ),
        9 => array(
          'var' => 'hitCount',
          'type' => TType::I32,
          ),
        10 => array(
          'var' => 'returnFields',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        20 => array(
          'var' => 'groupBy',
          'type' => TType::STRING,
          ),
        30 => array(
          'var' => 'groupFacets',
          'type' => TType::BOOL,
          ),
        40 => array(
          'var' => 'groupItemsCount',
          'type' => TType::I32,
          ),
        50 => array(
          'var' => 'groupItemsSort',
          'type' => TType::STRING,
          ),
        60 => array(
          'var' => 'groupItemsSortAscending',
          'type' => TType::BOOL,
          ),
        70 => array(
          'var' => 'hitsGroupsAsHits',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['indexId'])) {
        $this->indexId = $vals['indexId'];
      }
      if (isset($vals['language'])) {
        $this->language = $vals['language'];
      }
      if (isset($vals['queryText'])) {
        $this->queryText = $vals['queryText'];
      }
      if (isset($vals['filters'])) {
        $this->filters = $vals['filters'];
      }
      if (isset($vals['orFilters'])) {
        $this->orFilters = $vals['orFilters'];
      }
      if (isset($vals['facetRequests'])) {
        $this->facetRequests = $vals['facetRequests'];
      }
      if (isset($vals['sortFields'])) {
        $this->sortFields = $vals['sortFields'];
      }
      if (isset($vals['offset'])) {
        $this->offset = $vals['offset'];
      }
      if (isset($vals['hitCount'])) {
        $this->hitCount = $vals['hitCount'];
      }
      if (isset($vals['returnFields'])) {
        $this->returnFields = $vals['returnFields'];
      }
      if (isset($vals['groupBy'])) {
        $this->groupBy = $vals['groupBy'];
      }
      if (isset($vals['groupFacets'])) {
        $this->groupFacets = $vals['groupFacets'];
      }
      if (isset($vals['groupItemsCount'])) {
        $this->groupItemsCount = $vals['groupItemsCount'];
      }
      if (isset($vals['groupItemsSort'])) {
        $this->groupItemsSort = $vals['groupItemsSort'];
      }
      if (isset($vals['groupItemsSortAscending'])) {
        $this->groupItemsSortAscending = $vals['groupItemsSortAscending'];
      }
      if (isset($vals['hitsGroupsAsHits'])) {
        $this->hitsGroupsAsHits = $vals['hitsGroupsAsHits'];
      }
    }
  }

  public function getName() {
    return 'SimpleSearchQuery';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->indexId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->language);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queryText);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->filters = array();
            $_size28 = 0;
            $_etype31 = 0;
            $xfer += $input->readListBegin($_etype31, $_size28);
            for ($_i32 = 0; $_i32 < $_size28; ++$_i32)
            {
              $elem33 = null;
              $elem33 = new \com\boxalino\p13n\api\thrift\Filter();
              $xfer += $elem33->read($input);
              $this->filters []= $elem33;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->orFilters);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::LST) {
            $this->facetRequests = array();
            $_size34 = 0;
            $_etype37 = 0;
            $xfer += $input->readListBegin($_etype37, $_size34);
            for ($_i38 = 0; $_i38 < $_size34; ++$_i38)
            {
              $elem39 = null;
              $elem39 = new \com\boxalino\p13n\api\thrift\FacetRequest();
              $xfer += $elem39->read($input);
              $this->facetRequests []= $elem39;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::LST) {
            $this->sortFields = array();
            $_size40 = 0;
            $_etype43 = 0;
            $xfer += $input->readListBegin($_etype43, $_size40);
            for ($_i44 = 0; $_i44 < $_size40; ++$_i44)
            {
              $elem45 = null;
              $elem45 = new \com\boxalino\p13n\api\thrift\SortField();
              $xfer += $elem45->read($input);
              $this->sortFields []= $elem45;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->offset);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->hitCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::LST) {
            $this->returnFields = array();
            $_size46 = 0;
            $_etype49 = 0;
            $xfer += $input->readListBegin($_etype49, $_size46);
            for ($_i50 = 0; $_i50 < $_size46; ++$_i50)
            {
              $elem51 = null;
              $xfer += $input->readString($elem51);
              $this->returnFields []= $elem51;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 20:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->groupBy);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 30:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->groupFacets);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 40:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->groupItemsCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 50:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->groupItemsSort);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 60:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->groupItemsSortAscending);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 70:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->hitsGroupsAsHits);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SimpleSearchQuery');
    if ($this->indexId !== null) {
      $xfer += $output->writeFieldBegin('indexId', TType::STRING, 1);
      $xfer += $output->writeString($this->indexId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->language !== null) {
      $xfer += $output->writeFieldBegin('language', TType::STRING, 2);
      $xfer += $output->writeString($this->language);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queryText !== null) {
      $xfer += $output->writeFieldBegin('queryText', TType::STRING, 3);
      $xfer += $output->writeString($this->queryText);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filters !== null) {
      if (!is_array($this->filters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('filters', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRUCT, count($this->filters));
        {
          foreach ($this->filters as $iter52)
          {
            $xfer += $iter52->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->orFilters !== null) {
      $xfer += $output->writeFieldBegin('orFilters', TType::BOOL, 5);
      $xfer += $output->writeBool($this->orFilters);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->facetRequests !== null) {
      if (!is_array($this->facetRequests)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('facetRequests', TType::LST, 6);
      {
        $output->writeListBegin(TType::STRUCT, count($this->facetRequests));
        {
          foreach ($this->facetRequests as $iter53)
          {
            $xfer += $iter53->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sortFields !== null) {
      if (!is_array($this->sortFields)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sortFields', TType::LST, 7);
      {
        $output->writeListBegin(TType::STRUCT, count($this->sortFields));
        {
          foreach ($this->sortFields as $iter54)
          {
            $xfer += $iter54->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->offset !== null) {
      $xfer += $output->writeFieldBegin('offset', TType::I64, 8);
      $xfer += $output->writeI64($this->offset);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hitCount !== null) {
      $xfer += $output->writeFieldBegin('hitCount', TType::I32, 9);
      $xfer += $output->writeI32($this->hitCount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->returnFields !== null) {
      if (!is_array($this->returnFields)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('returnFields', TType::LST, 10);
      {
        $output->writeListBegin(TType::STRING, count($this->returnFields));
        {
          foreach ($this->returnFields as $iter55)
          {
            $xfer += $output->writeString($iter55);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->groupBy !== null) {
      $xfer += $output->writeFieldBegin('groupBy', TType::STRING, 20);
      $xfer += $output->writeString($this->groupBy);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->groupFacets !== null) {
      $xfer += $output->writeFieldBegin('groupFacets', TType::BOOL, 30);
      $xfer += $output->writeBool($this->groupFacets);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->groupItemsCount !== null) {
      $xfer += $output->writeFieldBegin('groupItemsCount', TType::I32, 40);
      $xfer += $output->writeI32($this->groupItemsCount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->groupItemsSort !== null) {
      $xfer += $output->writeFieldBegin('groupItemsSort', TType::STRING, 50);
      $xfer += $output->writeString($this->groupItemsSort);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->groupItemsSortAscending !== null) {
      $xfer += $output->writeFieldBegin('groupItemsSortAscending', TType::BOOL, 60);
      $xfer += $output->writeBool($this->groupItemsSortAscending);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hitsGroupsAsHits !== null) {
      $xfer += $output->writeFieldBegin('hitsGroupsAsHits', TType::BOOL, 70);
      $xfer += $output->writeBool($this->hitsGroupsAsHits);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * <dl>
 * <dt>indexId</dt>
 * <dd>id of the index to fetch context item data from</dd>
 * 
 * <dt>fieldName</dt>
 * <dd>the field name of the item's unique identifier within the items index</dd>
 * <dd>for example: 'sku' for items 'products'</dd>
 * 
 * <dt>contextItemId</dt>
 * <dd>actual item's identifier</dd>
 * <dd>for example: actual sku of the product</dd>
 * 
 * <dt>role</dt>
 * <dd>role of the item within the context, used to address the item in the
 * recommendation script.</dd>
 * <dd>for example: 'main product' for recommendations within product detail
 * page</dd>
 * </dl>
 */
class ContextItem {
  static $_TSPEC;

  /**
   * @var string
   */
  public $indexId = null;
  /**
   * @var string
   */
  public $fieldName = null;
  /**
   * @var string
   */
  public $contextItemId = null;
  /**
   * @var string
   */
  public $role = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'indexId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'fieldName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'contextItemId',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'role',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['indexId'])) {
        $this->indexId = $vals['indexId'];
      }
      if (isset($vals['fieldName'])) {
        $this->fieldName = $vals['fieldName'];
      }
      if (isset($vals['contextItemId'])) {
        $this->contextItemId = $vals['contextItemId'];
      }
      if (isset($vals['role'])) {
        $this->role = $vals['role'];
      }
    }
  }

  public function getName() {
    return 'ContextItem';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->indexId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fieldName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->contextItemId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->role);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ContextItem');
    if ($this->indexId !== null) {
      $xfer += $output->writeFieldBegin('indexId', TType::STRING, 1);
      $xfer += $output->writeString($this->indexId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fieldName !== null) {
      $xfer += $output->writeFieldBegin('fieldName', TType::STRING, 2);
      $xfer += $output->writeString($this->fieldName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->contextItemId !== null) {
      $xfer += $output->writeFieldBegin('contextItemId', TType::STRING, 3);
      $xfer += $output->writeString($this->contextItemId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->role !== null) {
      $xfer += $output->writeFieldBegin('role', TType::STRING, 4);
      $xfer += $output->writeString($this->role);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * <dl>
 * <dt>choiceId</dt>
 * <dd>personalization choice identificator</dd>
 * 
 * <dt>simpleSearchQuery</dt>
 * <dd>search query in a case of recommendation and search inquiries</dd>
 * 
 * <dt>contextItems</dt>
 * <dd>context items for recommendations</dd>
 * 
 * <dt>minHitCount</dt>
 * <dd>minimal hit count to return for recommendations.</dd>
 * <dd>if higher priority recommendation strategy yields less results, next
 * strategy is tried</dd>
 * 
 * <dt>excludeVariantIds</dt>
 * <dd>set of variantIds to be excluded from result, has no effect if null or empty</dd>
 * 
 * <dt>includeVariantIds</dt>
 * <dd>set of variantIds to be included in the result, has no effect if null or empty</dd>
 * 
 * <dt>scope</dt>
 * <dd>choice source to be used</dd>
 * 
 * <dt>withRelaxation</dt>
 * <dd>if search relaxation should be used</dd>
 * </dl>
 */
class ChoiceInquiry {
  static $_TSPEC;

  /**
   * @var string
   */
  public $choiceId = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\SimpleSearchQuery
   */
  public $simpleSearchQuery = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\ContextItem[]
   */
  public $contextItems = null;
  /**
   * @var int
   */
  public $minHitCount = null;
  /**
   * @var string[]
   */
  public $excludeVariantIds = null;
  /**
   * @var string
   */
  public $scope = "system_rec";
  /**
   * @var bool
   */
  public $withRelaxation = false;
  /**
   * @var bool
   */
  public $withSemanticFiltering = false;
  /**
   * @var string[]
   */
  public $includeVariantIds = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'choiceId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'simpleSearchQuery',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\p13n\api\thrift\SimpleSearchQuery',
          ),
        3 => array(
          'var' => 'contextItems',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\ContextItem',
            ),
          ),
        4 => array(
          'var' => 'minHitCount',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'excludeVariantIds',
          'type' => TType::SET,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        6 => array(
          'var' => 'scope',
          'type' => TType::STRING,
          ),
        70 => array(
          'var' => 'withRelaxation',
          'type' => TType::BOOL,
          ),
        80 => array(
          'var' => 'withSemanticFiltering',
          'type' => TType::BOOL,
          ),
        90 => array(
          'var' => 'includeVariantIds',
          'type' => TType::SET,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['choiceId'])) {
        $this->choiceId = $vals['choiceId'];
      }
      if (isset($vals['simpleSearchQuery'])) {
        $this->simpleSearchQuery = $vals['simpleSearchQuery'];
      }
      if (isset($vals['contextItems'])) {
        $this->contextItems = $vals['contextItems'];
      }
      if (isset($vals['minHitCount'])) {
        $this->minHitCount = $vals['minHitCount'];
      }
      if (isset($vals['excludeVariantIds'])) {
        $this->excludeVariantIds = $vals['excludeVariantIds'];
      }
      if (isset($vals['scope'])) {
        $this->scope = $vals['scope'];
      }
      if (isset($vals['withRelaxation'])) {
        $this->withRelaxation = $vals['withRelaxation'];
      }
      if (isset($vals['withSemanticFiltering'])) {
        $this->withSemanticFiltering = $vals['withSemanticFiltering'];
      }
      if (isset($vals['includeVariantIds'])) {
        $this->includeVariantIds = $vals['includeVariantIds'];
      }
    }
  }

  public function getName() {
    return 'ChoiceInquiry';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->choiceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->simpleSearchQuery = new \com\boxalino\p13n\api\thrift\SimpleSearchQuery();
            $xfer += $this->simpleSearchQuery->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->contextItems = array();
            $_size56 = 0;
            $_etype59 = 0;
            $xfer += $input->readListBegin($_etype59, $_size56);
            for ($_i60 = 0; $_i60 < $_size56; ++$_i60)
            {
              $elem61 = null;
              $elem61 = new \com\boxalino\p13n\api\thrift\ContextItem();
              $xfer += $elem61->read($input);
              $this->contextItems []= $elem61;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->minHitCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::SET) {
            $this->excludeVariantIds = array();
            $_size62 = 0;
            $_etype65 = 0;
            $xfer += $input->readSetBegin($_etype65, $_size62);
            for ($_i66 = 0; $_i66 < $_size62; ++$_i66)
            {
              $elem67 = null;
              $xfer += $input->readString($elem67);
              if (is_scalar($elem67)) {
                $this->excludeVariantIds[$elem67] = true;
              } else {
                $this->excludeVariantIds []= $elem67;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->scope);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 70:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->withRelaxation);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 80:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->withSemanticFiltering);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 90:
          if ($ftype == TType::SET) {
            $this->includeVariantIds = array();
            $_size68 = 0;
            $_etype71 = 0;
            $xfer += $input->readSetBegin($_etype71, $_size68);
            for ($_i72 = 0; $_i72 < $_size68; ++$_i72)
            {
              $elem73 = null;
              $xfer += $input->readString($elem73);
              if (is_scalar($elem73)) {
                $this->includeVariantIds[$elem73] = true;
              } else {
                $this->includeVariantIds []= $elem73;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ChoiceInquiry');
    if ($this->choiceId !== null) {
      $xfer += $output->writeFieldBegin('choiceId', TType::STRING, 1);
      $xfer += $output->writeString($this->choiceId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->simpleSearchQuery !== null) {
      if (!is_object($this->simpleSearchQuery)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('simpleSearchQuery', TType::STRUCT, 2);
      $xfer += $this->simpleSearchQuery->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->contextItems !== null) {
      if (!is_array($this->contextItems)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('contextItems', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->contextItems));
        {
          foreach ($this->contextItems as $iter74)
          {
            $xfer += $iter74->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->minHitCount !== null) {
      $xfer += $output->writeFieldBegin('minHitCount', TType::I32, 4);
      $xfer += $output->writeI32($this->minHitCount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->excludeVariantIds !== null) {
      if (!is_array($this->excludeVariantIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('excludeVariantIds', TType::SET, 5);
      {
        $output->writeSetBegin(TType::STRING, count($this->excludeVariantIds));
        {
          foreach ($this->excludeVariantIds as $iter75 => $iter76)
          {
            if (is_scalar($iter76)) {
            $xfer += $output->writeString($iter75);
            } else {
            $xfer += $output->writeString($iter76);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->scope !== null) {
      $xfer += $output->writeFieldBegin('scope', TType::STRING, 6);
      $xfer += $output->writeString($this->scope);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->withRelaxation !== null) {
      $xfer += $output->writeFieldBegin('withRelaxation', TType::BOOL, 70);
      $xfer += $output->writeBool($this->withRelaxation);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->withSemanticFiltering !== null) {
      $xfer += $output->writeFieldBegin('withSemanticFiltering', TType::BOOL, 80);
      $xfer += $output->writeBool($this->withSemanticFiltering);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->includeVariantIds !== null) {
      if (!is_array($this->includeVariantIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('includeVariantIds', TType::SET, 90);
      {
        $output->writeSetBegin(TType::STRING, count($this->includeVariantIds));
        {
          foreach ($this->includeVariantIds as $iter77 => $iter78)
          {
            if (is_scalar($iter78)) {
            $xfer += $output->writeString($iter77);
            } else {
            $xfer += $output->writeString($iter78);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * parameters of request context. Usually browser, platform, etc.
 */
class RequestContext {
  static $_TSPEC;

  /**
   * @var array
   */
  public $parameters = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'parameters',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
              'type' => TType::STRING,
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['parameters'])) {
        $this->parameters = $vals['parameters'];
      }
    }
  }

  public function getName() {
    return 'RequestContext';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->parameters = array();
            $_size79 = 0;
            $_ktype80 = 0;
            $_vtype81 = 0;
            $xfer += $input->readMapBegin($_ktype80, $_vtype81, $_size79);
            for ($_i83 = 0; $_i83 < $_size79; ++$_i83)
            {
              $key84 = '';
              $val85 = array();
              $xfer += $input->readString($key84);
              $val85 = array();
              $_size86 = 0;
              $_etype89 = 0;
              $xfer += $input->readListBegin($_etype89, $_size86);
              for ($_i90 = 0; $_i90 < $_size86; ++$_i90)
              {
                $elem91 = null;
                $xfer += $input->readString($elem91);
                $val85 []= $elem91;
              }
              $xfer += $input->readListEnd();
              $this->parameters[$key84] = $val85;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RequestContext');
    if ($this->parameters !== null) {
      if (!is_array($this->parameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parameters', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::LST, count($this->parameters));
        {
          foreach ($this->parameters as $kiter92 => $viter93)
          {
            $xfer += $output->writeString($kiter92);
            {
              $output->writeListBegin(TType::STRING, count($viter93));
              {
                foreach ($viter93 as $iter94)
                {
                  $xfer += $output->writeString($iter94);
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * unique identifier of the customer
 */
class UserRecord {
  static $_TSPEC;

  /**
   * @var string
   */
  public $username = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'username',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['username'])) {
        $this->username = $vals['username'];
      }
    }
  }

  public function getName() {
    return 'UserRecord';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->username);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('UserRecord');
    if ($this->username !== null) {
      $xfer += $output->writeFieldBegin('username', TType::STRING, 1);
      $xfer += $output->writeString($this->username);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * <dl>
 * <dt>profileId</dt>
 * <dd>profile (visitor) identificator</dd>
 * 
 * <dt>inquiries</dt>
 * <dd>list of inquiries to be executed sequentially.</dd>
 * <dd>Inquiries with higher index may depend from those with lower index.</dd>
 * 
 * <dt>requestContext</dt>
 * <dd>context of the request</dd>
 * </dl>
 */
class ChoiceRequest {
  static $_TSPEC;

  /**
   * @var \com\boxalino\p13n\api\thrift\UserRecord
   */
  public $userRecord = null;
  /**
   * @var string
   */
  public $profileId = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\ChoiceInquiry[]
   */
  public $inquiries = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\RequestContext
   */
  public $requestContext = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'userRecord',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\p13n\api\thrift\UserRecord',
          ),
        2 => array(
          'var' => 'profileId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'inquiries',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\ChoiceInquiry',
            ),
          ),
        4 => array(
          'var' => 'requestContext',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\p13n\api\thrift\RequestContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['userRecord'])) {
        $this->userRecord = $vals['userRecord'];
      }
      if (isset($vals['profileId'])) {
        $this->profileId = $vals['profileId'];
      }
      if (isset($vals['inquiries'])) {
        $this->inquiries = $vals['inquiries'];
      }
      if (isset($vals['requestContext'])) {
        $this->requestContext = $vals['requestContext'];
      }
    }
  }

  public function getName() {
    return 'ChoiceRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->userRecord = new \com\boxalino\p13n\api\thrift\UserRecord();
            $xfer += $this->userRecord->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->profileId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->inquiries = array();
            $_size95 = 0;
            $_etype98 = 0;
            $xfer += $input->readListBegin($_etype98, $_size95);
            for ($_i99 = 0; $_i99 < $_size95; ++$_i99)
            {
              $elem100 = null;
              $elem100 = new \com\boxalino\p13n\api\thrift\ChoiceInquiry();
              $xfer += $elem100->read($input);
              $this->inquiries []= $elem100;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->requestContext = new \com\boxalino\p13n\api\thrift\RequestContext();
            $xfer += $this->requestContext->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ChoiceRequest');
    if ($this->userRecord !== null) {
      if (!is_object($this->userRecord)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userRecord', TType::STRUCT, 1);
      $xfer += $this->userRecord->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->profileId !== null) {
      $xfer += $output->writeFieldBegin('profileId', TType::STRING, 2);
      $xfer += $output->writeString($this->profileId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->inquiries !== null) {
      if (!is_array($this->inquiries)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('inquiries', TType::LST, 3);
      {
        $output->writeListBegin(TType::STRUCT, count($this->inquiries));
        {
          foreach ($this->inquiries as $iter101)
          {
            $xfer += $iter101->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->requestContext !== null) {
      if (!is_object($this->requestContext)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('requestContext', TType::STRUCT, 4);
      $xfer += $this->requestContext->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * <dl>
 * <dt>fieldName</dt>
 * <dd>name of the facet field</dd>
 * 
 * <dt>values</dt>
 * <dd>list of facet values</dd>
 * </dl>
 */
class FacetResponse {
  static $_TSPEC;

  /**
   * @var string
   */
  public $fieldName = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\FacetValue[]
   */
  public $values = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'fieldName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'values',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\FacetValue',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['fieldName'])) {
        $this->fieldName = $vals['fieldName'];
      }
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
    }
  }

  public function getName() {
    return 'FacetResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fieldName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->values = array();
            $_size102 = 0;
            $_etype105 = 0;
            $xfer += $input->readListBegin($_etype105, $_size102);
            for ($_i106 = 0; $_i106 < $_size102; ++$_i106)
            {
              $elem107 = null;
              $elem107 = new \com\boxalino\p13n\api\thrift\FacetValue();
              $xfer += $elem107->read($input);
              $this->values []= $elem107;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('FacetResponse');
    if ($this->fieldName !== null) {
      $xfer += $output->writeFieldBegin('fieldName', TType::STRING, 1);
      $xfer += $output->writeString($this->fieldName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->values));
        {
          foreach ($this->values as $iter108)
          {
            $xfer += $iter108->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * item found
 * 
 * <dl>
 * <dt>values</dt>
 * <dd>map containing name of the field and list of values as strings</dd>
 * <dd>if index contains no value for a field, empty array will be returned.</dd>
 * 
 * <dt>score</dt>
 * <dd>index score of the hit</dd>
 * 
 * <dt>scenarioId</dt>
 * <dd>source scenarioId in case of mixed recommendations modes</dd>
 * </dl>
 */
class Hit {
  static $_TSPEC;

  /**
   * @var array
   */
  public $values = null;
  /**
   * @var double
   */
  public $score = null;
  /**
   * @var string
   */
  public $scenarioId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'values',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::LST,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::LST,
            'etype' => TType::STRING,
            'elem' => array(
              'type' => TType::STRING,
              ),
            ),
          ),
        2 => array(
          'var' => 'score',
          'type' => TType::DOUBLE,
          ),
        30 => array(
          'var' => 'scenarioId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['values'])) {
        $this->values = $vals['values'];
      }
      if (isset($vals['score'])) {
        $this->score = $vals['score'];
      }
      if (isset($vals['scenarioId'])) {
        $this->scenarioId = $vals['scenarioId'];
      }
    }
  }

  public function getName() {
    return 'Hit';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->values = array();
            $_size109 = 0;
            $_ktype110 = 0;
            $_vtype111 = 0;
            $xfer += $input->readMapBegin($_ktype110, $_vtype111, $_size109);
            for ($_i113 = 0; $_i113 < $_size109; ++$_i113)
            {
              $key114 = '';
              $val115 = array();
              $xfer += $input->readString($key114);
              $val115 = array();
              $_size116 = 0;
              $_etype119 = 0;
              $xfer += $input->readListBegin($_etype119, $_size116);
              for ($_i120 = 0; $_i120 < $_size116; ++$_i120)
              {
                $elem121 = null;
                $xfer += $input->readString($elem121);
                $val115 []= $elem121;
              }
              $xfer += $input->readListEnd();
              $this->values[$key114] = $val115;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->score);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 30:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->scenarioId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Hit');
    if ($this->values !== null) {
      if (!is_array($this->values)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('values', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::LST, count($this->values));
        {
          foreach ($this->values as $kiter122 => $viter123)
          {
            $xfer += $output->writeString($kiter122);
            {
              $output->writeListBegin(TType::STRING, count($viter123));
              {
                foreach ($viter123 as $iter124)
                {
                  $xfer += $output->writeString($iter124);
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->score !== null) {
      $xfer += $output->writeFieldBegin('score', TType::DOUBLE, 2);
      $xfer += $output->writeDouble($this->score);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->scenarioId !== null) {
      $xfer += $output->writeFieldBegin('scenarioId', TType::STRING, 30);
      $xfer += $output->writeString($this->scenarioId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * grouped item found
 * 
 * <dl>
 * <dt>groupValue</dt>
 * <dd>value of the groupBy field</dd>
 * 
 * <dt>totalHitCount</dt>
 * <dd>total hits count within the group</dd>
 * 
 * <dt>hits</dt>
 * <dd>group hits</dd>
 * </dl>
 */
class HitsGroup {
  static $_TSPEC;

  /**
   * @var string
   */
  public $groupValue = null;
  /**
   * @var int
   */
  public $totalHitCount = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\Hit[]
   */
  public $hits = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'groupValue',
          'type' => TType::STRING,
          ),
        20 => array(
          'var' => 'totalHitCount',
          'type' => TType::I64,
          ),
        30 => array(
          'var' => 'hits',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\Hit',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['groupValue'])) {
        $this->groupValue = $vals['groupValue'];
      }
      if (isset($vals['totalHitCount'])) {
        $this->totalHitCount = $vals['totalHitCount'];
      }
      if (isset($vals['hits'])) {
        $this->hits = $vals['hits'];
      }
    }
  }

  public function getName() {
    return 'HitsGroup';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->groupValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 20:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->totalHitCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 30:
          if ($ftype == TType::LST) {
            $this->hits = array();
            $_size125 = 0;
            $_etype128 = 0;
            $xfer += $input->readListBegin($_etype128, $_size125);
            for ($_i129 = 0; $_i129 < $_size125; ++$_i129)
            {
              $elem130 = null;
              $elem130 = new \com\boxalino\p13n\api\thrift\Hit();
              $xfer += $elem130->read($input);
              $this->hits []= $elem130;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('HitsGroup');
    if ($this->groupValue !== null) {
      $xfer += $output->writeFieldBegin('groupValue', TType::STRING, 10);
      $xfer += $output->writeString($this->groupValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->totalHitCount !== null) {
      $xfer += $output->writeFieldBegin('totalHitCount', TType::I64, 20);
      $xfer += $output->writeI64($this->totalHitCount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hits !== null) {
      if (!is_array($this->hits)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hits', TType::LST, 30);
      {
        $output->writeListBegin(TType::STRUCT, count($this->hits));
        {
          foreach ($this->hits as $iter131)
          {
            $xfer += $iter131->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * <dl>
 * <dt>hits</dt>
 * <dd>list of hits found for given SimpleSearchQuery</dd>
 * 
 * <dt>facetResponses</dt>
 * <dd>list of requested facets or null if none requested</dd>
 * 
 * <dt>totalHitCount</dt>
 * <dd>total number of hits; -1 in case of mixed recommendation strategy</dd>
 * 
 * <dt>queryText</dt>
 * <dd>relaxation query text for relaxation results or requested queryText for a
 * regular SearchResult</dd>
 * 
 * <dt>hitsGroups</dt>
 * <dd>grouped hits; not null when corresponding SimplSearchQuery has
 * groupBy!=null </dd>
 * </dl>
 */
class SearchResult {
  static $_TSPEC;

  /**
   * @var \com\boxalino\p13n\api\thrift\Hit[]
   */
  public $hits = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\FacetResponse[]
   */
  public $facetResponses = null;
  /**
   * @var int
   */
  public $totalHitCount = null;
  /**
   * @var string
   */
  public $queryText = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\HitsGroup[]
   */
  public $hitsGroups = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'hits',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\Hit',
            ),
          ),
        2 => array(
          'var' => 'facetResponses',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\FacetResponse',
            ),
          ),
        3 => array(
          'var' => 'totalHitCount',
          'type' => TType::I64,
          ),
        40 => array(
          'var' => 'queryText',
          'type' => TType::STRING,
          ),
        50 => array(
          'var' => 'hitsGroups',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\HitsGroup',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['hits'])) {
        $this->hits = $vals['hits'];
      }
      if (isset($vals['facetResponses'])) {
        $this->facetResponses = $vals['facetResponses'];
      }
      if (isset($vals['totalHitCount'])) {
        $this->totalHitCount = $vals['totalHitCount'];
      }
      if (isset($vals['queryText'])) {
        $this->queryText = $vals['queryText'];
      }
      if (isset($vals['hitsGroups'])) {
        $this->hitsGroups = $vals['hitsGroups'];
      }
    }
  }

  public function getName() {
    return 'SearchResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->hits = array();
            $_size132 = 0;
            $_etype135 = 0;
            $xfer += $input->readListBegin($_etype135, $_size132);
            for ($_i136 = 0; $_i136 < $_size132; ++$_i136)
            {
              $elem137 = null;
              $elem137 = new \com\boxalino\p13n\api\thrift\Hit();
              $xfer += $elem137->read($input);
              $this->hits []= $elem137;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->facetResponses = array();
            $_size138 = 0;
            $_etype141 = 0;
            $xfer += $input->readListBegin($_etype141, $_size138);
            for ($_i142 = 0; $_i142 < $_size138; ++$_i142)
            {
              $elem143 = null;
              $elem143 = new \com\boxalino\p13n\api\thrift\FacetResponse();
              $xfer += $elem143->read($input);
              $this->facetResponses []= $elem143;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->totalHitCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 40:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queryText);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 50:
          if ($ftype == TType::LST) {
            $this->hitsGroups = array();
            $_size144 = 0;
            $_etype147 = 0;
            $xfer += $input->readListBegin($_etype147, $_size144);
            for ($_i148 = 0; $_i148 < $_size144; ++$_i148)
            {
              $elem149 = null;
              $elem149 = new \com\boxalino\p13n\api\thrift\HitsGroup();
              $xfer += $elem149->read($input);
              $this->hitsGroups []= $elem149;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SearchResult');
    if ($this->hits !== null) {
      if (!is_array($this->hits)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hits', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->hits));
        {
          foreach ($this->hits as $iter150)
          {
            $xfer += $iter150->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->facetResponses !== null) {
      if (!is_array($this->facetResponses)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('facetResponses', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->facetResponses));
        {
          foreach ($this->facetResponses as $iter151)
          {
            $xfer += $iter151->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->totalHitCount !== null) {
      $xfer += $output->writeFieldBegin('totalHitCount', TType::I64, 3);
      $xfer += $output->writeI64($this->totalHitCount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queryText !== null) {
      $xfer += $output->writeFieldBegin('queryText', TType::STRING, 40);
      $xfer += $output->writeString($this->queryText);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hitsGroups !== null) {
      if (!is_array($this->hitsGroups)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hitsGroups', TType::LST, 50);
      {
        $output->writeListBegin(TType::STRUCT, count($this->hitsGroups));
        {
          foreach ($this->hitsGroups as $iter152)
          {
            $xfer += $iter152->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SearchRelaxation {
  static $_TSPEC;

  /**
   * @var \com\boxalino\p13n\api\thrift\SearchResult[]
   */
  public $suggestionsResults = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\SearchResult[]
   */
  public $subphrasesResults = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        10 => array(
          'var' => 'suggestionsResults',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\SearchResult',
            ),
          ),
        20 => array(
          'var' => 'subphrasesResults',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\SearchResult',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['suggestionsResults'])) {
        $this->suggestionsResults = $vals['suggestionsResults'];
      }
      if (isset($vals['subphrasesResults'])) {
        $this->subphrasesResults = $vals['subphrasesResults'];
      }
    }
  }

  public function getName() {
    return 'SearchRelaxation';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 10:
          if ($ftype == TType::LST) {
            $this->suggestionsResults = array();
            $_size153 = 0;
            $_etype156 = 0;
            $xfer += $input->readListBegin($_etype156, $_size153);
            for ($_i157 = 0; $_i157 < $_size153; ++$_i157)
            {
              $elem158 = null;
              $elem158 = new \com\boxalino\p13n\api\thrift\SearchResult();
              $xfer += $elem158->read($input);
              $this->suggestionsResults []= $elem158;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 20:
          if ($ftype == TType::LST) {
            $this->subphrasesResults = array();
            $_size159 = 0;
            $_etype162 = 0;
            $xfer += $input->readListBegin($_etype162, $_size159);
            for ($_i163 = 0; $_i163 < $_size159; ++$_i163)
            {
              $elem164 = null;
              $elem164 = new \com\boxalino\p13n\api\thrift\SearchResult();
              $xfer += $elem164->read($input);
              $this->subphrasesResults []= $elem164;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SearchRelaxation');
    if ($this->suggestionsResults !== null) {
      if (!is_array($this->suggestionsResults)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('suggestionsResults', TType::LST, 10);
      {
        $output->writeListBegin(TType::STRUCT, count($this->suggestionsResults));
        {
          foreach ($this->suggestionsResults as $iter165)
          {
            $xfer += $iter165->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subphrasesResults !== null) {
      if (!is_array($this->subphrasesResults)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subphrasesResults', TType::LST, 20);
      {
        $output->writeListBegin(TType::STRUCT, count($this->subphrasesResults));
        {
          foreach ($this->subphrasesResults as $iter166)
          {
            $xfer += $iter166->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * <dl>
 * <dt>variantId</dt>
 * <dd>id of the personalized variant</dd>
 * 
 * <dt>scenarioId</dt>
 * <dd>scenario identificator used to produce recommendation result or search
 * result personalization</dd>
 * 
 * <dt>searchResult</dt>
 * <dd>result of the search request for recommendations and search requests</dd>
 * 
 * <dt>searchResultTitle</dt>
 * <dd>recommendation's result title localized in language requested in
 * corresponding SimpleSearchQuery</dd>
 * 
 * <dt>searchRelaxation</dt>
 * <dd>When the service considers queryText invalid, it will evaluate and return
 * relaxations if it is requested in corresponding ChoiceInquiry and if
 * relaxations could be found.</dd>
 * <dd>Note that original query still could yield some results; it is up to the
 * client to decide whether searchRelaxations should be used (with displaying
 * appropriate message) or not.</dd>
 * </dl>
 */
class Variant {
  static $_TSPEC;

  /**
   * @var string
   */
  public $variantId = null;
  /**
   * @var string
   */
  public $scenarioId = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\SearchResult
   */
  public $searchResult = null;
  /**
   * @var string
   */
  public $searchResultTitle = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\SearchRelaxation
   */
  public $searchRelaxation = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\SearchResult[]
   */
  public $semanticFilteringResults = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'variantId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'scenarioId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'searchResult',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\p13n\api\thrift\SearchResult',
          ),
        4 => array(
          'var' => 'searchResultTitle',
          'type' => TType::STRING,
          ),
        50 => array(
          'var' => 'searchRelaxation',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\p13n\api\thrift\SearchRelaxation',
          ),
        60 => array(
          'var' => 'semanticFilteringResults',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\SearchResult',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['variantId'])) {
        $this->variantId = $vals['variantId'];
      }
      if (isset($vals['scenarioId'])) {
        $this->scenarioId = $vals['scenarioId'];
      }
      if (isset($vals['searchResult'])) {
        $this->searchResult = $vals['searchResult'];
      }
      if (isset($vals['searchResultTitle'])) {
        $this->searchResultTitle = $vals['searchResultTitle'];
      }
      if (isset($vals['searchRelaxation'])) {
        $this->searchRelaxation = $vals['searchRelaxation'];
      }
      if (isset($vals['semanticFilteringResults'])) {
        $this->semanticFilteringResults = $vals['semanticFilteringResults'];
      }
    }
  }

  public function getName() {
    return 'Variant';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->variantId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->scenarioId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->searchResult = new \com\boxalino\p13n\api\thrift\SearchResult();
            $xfer += $this->searchResult->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->searchResultTitle);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 50:
          if ($ftype == TType::STRUCT) {
            $this->searchRelaxation = new \com\boxalino\p13n\api\thrift\SearchRelaxation();
            $xfer += $this->searchRelaxation->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 60:
          if ($ftype == TType::LST) {
            $this->semanticFilteringResults = array();
            $_size167 = 0;
            $_etype170 = 0;
            $xfer += $input->readListBegin($_etype170, $_size167);
            for ($_i171 = 0; $_i171 < $_size167; ++$_i171)
            {
              $elem172 = null;
              $elem172 = new \com\boxalino\p13n\api\thrift\SearchResult();
              $xfer += $elem172->read($input);
              $this->semanticFilteringResults []= $elem172;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Variant');
    if ($this->variantId !== null) {
      $xfer += $output->writeFieldBegin('variantId', TType::STRING, 1);
      $xfer += $output->writeString($this->variantId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->scenarioId !== null) {
      $xfer += $output->writeFieldBegin('scenarioId', TType::STRING, 2);
      $xfer += $output->writeString($this->scenarioId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->searchResult !== null) {
      if (!is_object($this->searchResult)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('searchResult', TType::STRUCT, 3);
      $xfer += $this->searchResult->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->searchResultTitle !== null) {
      $xfer += $output->writeFieldBegin('searchResultTitle', TType::STRING, 4);
      $xfer += $output->writeString($this->searchResultTitle);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->searchRelaxation !== null) {
      if (!is_object($this->searchRelaxation)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('searchRelaxation', TType::STRUCT, 50);
      $xfer += $this->searchRelaxation->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->semanticFilteringResults !== null) {
      if (!is_array($this->semanticFilteringResults)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('semanticFilteringResults', TType::LST, 60);
      {
        $output->writeListBegin(TType::STRUCT, count($this->semanticFilteringResults));
        {
          foreach ($this->semanticFilteringResults as $iter173)
          {
            $xfer += $iter173->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * list of personalized variants. Item's index corresponds to the index of the
 * ChoiceInquiry
 */
class ChoiceResponse {
  static $_TSPEC;

  /**
   * @var \com\boxalino\p13n\api\thrift\Variant[]
   */
  public $variants = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'variants',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\Variant',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['variants'])) {
        $this->variants = $vals['variants'];
      }
    }
  }

  public function getName() {
    return 'ChoiceResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->variants = array();
            $_size174 = 0;
            $_etype177 = 0;
            $xfer += $input->readListBegin($_etype177, $_size174);
            for ($_i178 = 0; $_i178 < $_size174; ++$_i178)
            {
              $elem179 = null;
              $elem179 = new \com\boxalino\p13n\api\thrift\Variant();
              $xfer += $elem179->read($input);
              $this->variants []= $elem179;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ChoiceResponse');
    if ($this->variants !== null) {
      if (!is_array($this->variants)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('variants', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->variants));
        {
          foreach ($this->variants as $iter180)
          {
            $xfer += $iter180->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ProfilePropertyValue {
  static $_TSPEC;

  /**
   * @var string
   */
  public $profileId = null;
  /**
   * @var string
   */
  public $propertyName = null;
  /**
   * @var string
   */
  public $propertyValue = null;
  /**
   * @var int
   */
  public $confidence = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'profileId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'propertyName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'propertyValue',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'confidence',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['profileId'])) {
        $this->profileId = $vals['profileId'];
      }
      if (isset($vals['propertyName'])) {
        $this->propertyName = $vals['propertyName'];
      }
      if (isset($vals['propertyValue'])) {
        $this->propertyValue = $vals['propertyValue'];
      }
      if (isset($vals['confidence'])) {
        $this->confidence = $vals['confidence'];
      }
    }
  }

  public function getName() {
    return 'ProfilePropertyValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->profileId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->propertyName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->propertyValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->confidence);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ProfilePropertyValue');
    if ($this->profileId !== null) {
      $xfer += $output->writeFieldBegin('profileId', TType::STRING, 1);
      $xfer += $output->writeString($this->profileId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->propertyName !== null) {
      $xfer += $output->writeFieldBegin('propertyName', TType::STRING, 2);
      $xfer += $output->writeString($this->propertyName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->propertyValue !== null) {
      $xfer += $output->writeFieldBegin('propertyValue', TType::STRING, 3);
      $xfer += $output->writeString($this->propertyValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->confidence !== null) {
      $xfer += $output->writeFieldBegin('confidence', TType::I32, 4);
      $xfer += $output->writeI32($this->confidence);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ProfileContext {
  static $_TSPEC;

  /**
   * @var string
   */
  public $profileId = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\RequestContext
   */
  public $requestContext = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'profileId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'requestContext',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\p13n\api\thrift\RequestContext',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['profileId'])) {
        $this->profileId = $vals['profileId'];
      }
      if (isset($vals['requestContext'])) {
        $this->requestContext = $vals['requestContext'];
      }
    }
  }

  public function getName() {
    return 'ProfileContext';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->profileId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->requestContext = new \com\boxalino\p13n\api\thrift\RequestContext();
            $xfer += $this->requestContext->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ProfileContext');
    if ($this->profileId !== null) {
      $xfer += $output->writeFieldBegin('profileId', TType::STRING, 1);
      $xfer += $output->writeString($this->profileId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->requestContext !== null) {
      if (!is_object($this->requestContext)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('requestContext', TType::STRUCT, 2);
      $xfer += $this->requestContext->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * <dl>
 * <dt>choiceInquiry</dt>
 * <dd><b>deprecated</b> - use choiceInquiries instead.</dd>
 * <dd>If choiceInquiries is given this field will be ignored</dd>
 * 
 * <dt>choiceInquiries</dt>
 * <dd>list of ChoiceInquiries to be executed sequentially.</dd>
 * <dd>Note that list items can depend of items before in list</dd>
 * 
 * <dt>requestContext</dt>
 * <dd><b>deprecated</b> - use profileContexts instead.</dd>
 * 
 * <dt>profileIds</dt>
 * <dd><b>deprecated</b> - use profileContexts instead.</dd>
 * </dl>
 */
class BatchChoiceRequest {
  static $_TSPEC;

  /**
   * @var \com\boxalino\p13n\api\thrift\UserRecord
   */
  public $userRecord = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\ChoiceInquiry
   */
  public $choiceInquiry = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\RequestContext
   */
  public $requestContext = null;
  /**
   * @var string[]
   */
  public $profileIds = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\ChoiceInquiry[]
   */
  public $choiceInquiries = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\ProfileContext[]
   */
  public $profileContexts = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'userRecord',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\p13n\api\thrift\UserRecord',
          ),
        2 => array(
          'var' => 'choiceInquiry',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\p13n\api\thrift\ChoiceInquiry',
          ),
        3 => array(
          'var' => 'requestContext',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\p13n\api\thrift\RequestContext',
          ),
        4 => array(
          'var' => 'profileIds',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        5 => array(
          'var' => 'choiceInquiries',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\ChoiceInquiry',
            ),
          ),
        6 => array(
          'var' => 'profileContexts',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\ProfileContext',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['userRecord'])) {
        $this->userRecord = $vals['userRecord'];
      }
      if (isset($vals['choiceInquiry'])) {
        $this->choiceInquiry = $vals['choiceInquiry'];
      }
      if (isset($vals['requestContext'])) {
        $this->requestContext = $vals['requestContext'];
      }
      if (isset($vals['profileIds'])) {
        $this->profileIds = $vals['profileIds'];
      }
      if (isset($vals['choiceInquiries'])) {
        $this->choiceInquiries = $vals['choiceInquiries'];
      }
      if (isset($vals['profileContexts'])) {
        $this->profileContexts = $vals['profileContexts'];
      }
    }
  }

  public function getName() {
    return 'BatchChoiceRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->userRecord = new \com\boxalino\p13n\api\thrift\UserRecord();
            $xfer += $this->userRecord->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->choiceInquiry = new \com\boxalino\p13n\api\thrift\ChoiceInquiry();
            $xfer += $this->choiceInquiry->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->requestContext = new \com\boxalino\p13n\api\thrift\RequestContext();
            $xfer += $this->requestContext->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->profileIds = array();
            $_size181 = 0;
            $_etype184 = 0;
            $xfer += $input->readListBegin($_etype184, $_size181);
            for ($_i185 = 0; $_i185 < $_size181; ++$_i185)
            {
              $elem186 = null;
              $xfer += $input->readString($elem186);
              $this->profileIds []= $elem186;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->choiceInquiries = array();
            $_size187 = 0;
            $_etype190 = 0;
            $xfer += $input->readListBegin($_etype190, $_size187);
            for ($_i191 = 0; $_i191 < $_size187; ++$_i191)
            {
              $elem192 = null;
              $elem192 = new \com\boxalino\p13n\api\thrift\ChoiceInquiry();
              $xfer += $elem192->read($input);
              $this->choiceInquiries []= $elem192;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::LST) {
            $this->profileContexts = array();
            $_size193 = 0;
            $_etype196 = 0;
            $xfer += $input->readListBegin($_etype196, $_size193);
            for ($_i197 = 0; $_i197 < $_size193; ++$_i197)
            {
              $elem198 = null;
              $elem198 = new \com\boxalino\p13n\api\thrift\ProfileContext();
              $xfer += $elem198->read($input);
              $this->profileContexts []= $elem198;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BatchChoiceRequest');
    if ($this->userRecord !== null) {
      if (!is_object($this->userRecord)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userRecord', TType::STRUCT, 1);
      $xfer += $this->userRecord->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->choiceInquiry !== null) {
      if (!is_object($this->choiceInquiry)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('choiceInquiry', TType::STRUCT, 2);
      $xfer += $this->choiceInquiry->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->requestContext !== null) {
      if (!is_object($this->requestContext)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('requestContext', TType::STRUCT, 3);
      $xfer += $this->requestContext->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->profileIds !== null) {
      if (!is_array($this->profileIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('profileIds', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRING, count($this->profileIds));
        {
          foreach ($this->profileIds as $iter199)
          {
            $xfer += $output->writeString($iter199);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->choiceInquiries !== null) {
      if (!is_array($this->choiceInquiries)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('choiceInquiries', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRUCT, count($this->choiceInquiries));
        {
          foreach ($this->choiceInquiries as $iter200)
          {
            $xfer += $iter200->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->profileContexts !== null) {
      if (!is_array($this->profileContexts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('profileContexts', TType::LST, 6);
      {
        $output->writeListBegin(TType::STRUCT, count($this->profileContexts));
        {
          foreach ($this->profileContexts as $iter201)
          {
            $xfer += $iter201->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * <dl>
 * <dt>variants</dt>
 * <dd><b>deprecated</b> - contains non-null value only if
 * corresponding BatchChoiceRequest had only one ChoiceInquiry</dd>
 * 
 * <dt>selectedVariants</dt>
 * <dd>outer list corresponds to profileIds given in BatchChoiceRequest, while
 * inner list corresponds to list of ChoiceInquiries from BatchChoiceRequest</dd>
 * </dl>
 */
class BatchChoiceResponse {
  static $_TSPEC;

  /**
   * @var \com\boxalino\p13n\api\thrift\Variant[]
   */
  public $variants = null;
  /**
   * @var (\com\boxalino\p13n\api\thrift\Variant[])[]
   */
  public $selectedVariants = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'variants',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\Variant',
            ),
          ),
        2 => array(
          'var' => 'selectedVariants',
          'type' => TType::LST,
          'etype' => TType::LST,
          'elem' => array(
            'type' => TType::LST,
            'etype' => TType::STRUCT,
            'elem' => array(
              'type' => TType::STRUCT,
              'class' => '\com\boxalino\p13n\api\thrift\Variant',
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['variants'])) {
        $this->variants = $vals['variants'];
      }
      if (isset($vals['selectedVariants'])) {
        $this->selectedVariants = $vals['selectedVariants'];
      }
    }
  }

  public function getName() {
    return 'BatchChoiceResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->variants = array();
            $_size202 = 0;
            $_etype205 = 0;
            $xfer += $input->readListBegin($_etype205, $_size202);
            for ($_i206 = 0; $_i206 < $_size202; ++$_i206)
            {
              $elem207 = null;
              $elem207 = new \com\boxalino\p13n\api\thrift\Variant();
              $xfer += $elem207->read($input);
              $this->variants []= $elem207;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->selectedVariants = array();
            $_size208 = 0;
            $_etype211 = 0;
            $xfer += $input->readListBegin($_etype211, $_size208);
            for ($_i212 = 0; $_i212 < $_size208; ++$_i212)
            {
              $elem213 = null;
              $elem213 = array();
              $_size214 = 0;
              $_etype217 = 0;
              $xfer += $input->readListBegin($_etype217, $_size214);
              for ($_i218 = 0; $_i218 < $_size214; ++$_i218)
              {
                $elem219 = null;
                $elem219 = new \com\boxalino\p13n\api\thrift\Variant();
                $xfer += $elem219->read($input);
                $elem213 []= $elem219;
              }
              $xfer += $input->readListEnd();
              $this->selectedVariants []= $elem213;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BatchChoiceResponse');
    if ($this->variants !== null) {
      if (!is_array($this->variants)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('variants', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->variants));
        {
          foreach ($this->variants as $iter220)
          {
            $xfer += $iter220->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->selectedVariants !== null) {
      if (!is_array($this->selectedVariants)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('selectedVariants', TType::LST, 2);
      {
        $output->writeListBegin(TType::LST, count($this->selectedVariants));
        {
          foreach ($this->selectedVariants as $iter221)
          {
            {
              $output->writeListBegin(TType::STRUCT, count($iter221));
              {
                foreach ($iter221 as $iter222)
                {
                  $xfer += $iter222->write($output);
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AutocompleteHit {
  static $_TSPEC;

  /**
   * @var string
   */
  public $suggestion = null;
  /**
   * @var string
   */
  public $highlighted = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\SearchResult
   */
  public $searchResult = null;
  /**
   * @var double
   */
  public $score = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        11 => array(
          'var' => 'suggestion',
          'type' => TType::STRING,
          ),
        21 => array(
          'var' => 'highlighted',
          'type' => TType::STRING,
          ),
        31 => array(
          'var' => 'searchResult',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\p13n\api\thrift\SearchResult',
          ),
        41 => array(
          'var' => 'score',
          'type' => TType::DOUBLE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['suggestion'])) {
        $this->suggestion = $vals['suggestion'];
      }
      if (isset($vals['highlighted'])) {
        $this->highlighted = $vals['highlighted'];
      }
      if (isset($vals['searchResult'])) {
        $this->searchResult = $vals['searchResult'];
      }
      if (isset($vals['score'])) {
        $this->score = $vals['score'];
      }
    }
  }

  public function getName() {
    return 'AutocompleteHit';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->suggestion);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 21:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->highlighted);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 31:
          if ($ftype == TType::STRUCT) {
            $this->searchResult = new \com\boxalino\p13n\api\thrift\SearchResult();
            $xfer += $this->searchResult->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 41:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->score);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AutocompleteHit');
    if ($this->suggestion !== null) {
      $xfer += $output->writeFieldBegin('suggestion', TType::STRING, 11);
      $xfer += $output->writeString($this->suggestion);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->highlighted !== null) {
      $xfer += $output->writeFieldBegin('highlighted', TType::STRING, 21);
      $xfer += $output->writeString($this->highlighted);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->searchResult !== null) {
      if (!is_object($this->searchResult)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('searchResult', TType::STRUCT, 31);
      $xfer += $this->searchResult->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->score !== null) {
      $xfer += $output->writeFieldBegin('score', TType::DOUBLE, 41);
      $xfer += $output->writeDouble($this->score);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AutocompleteQuery {
  static $_TSPEC;

  /**
   * @var string
   */
  public $indexId = null;
  /**
   * @var string
   */
  public $language = null;
  /**
   * @var string
   */
  public $queryText = null;
  /**
   * @var int
   */
  public $suggestionsHitCount = null;
  /**
   * @var bool
   */
  public $highlight = null;
  /**
   * @var string
   */
  public $highlightPre = "<em>";
  /**
   * @var string
   */
  public $highlightPost = "</em>";

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        11 => array(
          'var' => 'indexId',
          'type' => TType::STRING,
          ),
        21 => array(
          'var' => 'language',
          'type' => TType::STRING,
          ),
        31 => array(
          'var' => 'queryText',
          'type' => TType::STRING,
          ),
        41 => array(
          'var' => 'suggestionsHitCount',
          'type' => TType::I32,
          ),
        51 => array(
          'var' => 'highlight',
          'type' => TType::BOOL,
          ),
        61 => array(
          'var' => 'highlightPre',
          'type' => TType::STRING,
          ),
        71 => array(
          'var' => 'highlightPost',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['indexId'])) {
        $this->indexId = $vals['indexId'];
      }
      if (isset($vals['language'])) {
        $this->language = $vals['language'];
      }
      if (isset($vals['queryText'])) {
        $this->queryText = $vals['queryText'];
      }
      if (isset($vals['suggestionsHitCount'])) {
        $this->suggestionsHitCount = $vals['suggestionsHitCount'];
      }
      if (isset($vals['highlight'])) {
        $this->highlight = $vals['highlight'];
      }
      if (isset($vals['highlightPre'])) {
        $this->highlightPre = $vals['highlightPre'];
      }
      if (isset($vals['highlightPost'])) {
        $this->highlightPost = $vals['highlightPost'];
      }
    }
  }

  public function getName() {
    return 'AutocompleteQuery';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->indexId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 21:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->language);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 31:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->queryText);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 41:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->suggestionsHitCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 51:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->highlight);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 61:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->highlightPre);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 71:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->highlightPost);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AutocompleteQuery');
    if ($this->indexId !== null) {
      $xfer += $output->writeFieldBegin('indexId', TType::STRING, 11);
      $xfer += $output->writeString($this->indexId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->language !== null) {
      $xfer += $output->writeFieldBegin('language', TType::STRING, 21);
      $xfer += $output->writeString($this->language);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->queryText !== null) {
      $xfer += $output->writeFieldBegin('queryText', TType::STRING, 31);
      $xfer += $output->writeString($this->queryText);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->suggestionsHitCount !== null) {
      $xfer += $output->writeFieldBegin('suggestionsHitCount', TType::I32, 41);
      $xfer += $output->writeI32($this->suggestionsHitCount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->highlight !== null) {
      $xfer += $output->writeFieldBegin('highlight', TType::BOOL, 51);
      $xfer += $output->writeBool($this->highlight);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->highlightPre !== null) {
      $xfer += $output->writeFieldBegin('highlightPre', TType::STRING, 61);
      $xfer += $output->writeString($this->highlightPre);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->highlightPost !== null) {
      $xfer += $output->writeFieldBegin('highlightPost', TType::STRING, 71);
      $xfer += $output->writeString($this->highlightPost);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AutocompleteRequest {
  static $_TSPEC;

  /**
   * @var \com\boxalino\p13n\api\thrift\UserRecord
   */
  public $userRecord = null;
  /**
   * @var string
   */
  public $scope = "system_rec";
  /**
   * @var string
   */
  public $choiceId = null;
  /**
   * @var string
   */
  public $profileId = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\RequestContext
   */
  public $requestContext = null;
  /**
   * @var string[]
   */
  public $excludeVariantIds = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\AutocompleteQuery
   */
  public $autocompleteQuery = null;
  /**
   * @var string
   */
  public $searchChoiceId = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\SimpleSearchQuery
   */
  public $searchQuery = null;
  /**
   * @var string[]
   */
  public $includeVariantIds = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\PropertyQuery[]
   */
  public $propertyQueries = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        11 => array(
          'var' => 'userRecord',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\p13n\api\thrift\UserRecord',
          ),
        21 => array(
          'var' => 'scope',
          'type' => TType::STRING,
          ),
        31 => array(
          'var' => 'choiceId',
          'type' => TType::STRING,
          ),
        41 => array(
          'var' => 'profileId',
          'type' => TType::STRING,
          ),
        51 => array(
          'var' => 'requestContext',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\p13n\api\thrift\RequestContext',
          ),
        61 => array(
          'var' => 'excludeVariantIds',
          'type' => TType::SET,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        71 => array(
          'var' => 'autocompleteQuery',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\p13n\api\thrift\AutocompleteQuery',
          ),
        81 => array(
          'var' => 'searchChoiceId',
          'type' => TType::STRING,
          ),
        91 => array(
          'var' => 'searchQuery',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\p13n\api\thrift\SimpleSearchQuery',
          ),
        101 => array(
          'var' => 'includeVariantIds',
          'type' => TType::SET,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        110 => array(
          'var' => 'propertyQueries',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\PropertyQuery',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['userRecord'])) {
        $this->userRecord = $vals['userRecord'];
      }
      if (isset($vals['scope'])) {
        $this->scope = $vals['scope'];
      }
      if (isset($vals['choiceId'])) {
        $this->choiceId = $vals['choiceId'];
      }
      if (isset($vals['profileId'])) {
        $this->profileId = $vals['profileId'];
      }
      if (isset($vals['requestContext'])) {
        $this->requestContext = $vals['requestContext'];
      }
      if (isset($vals['excludeVariantIds'])) {
        $this->excludeVariantIds = $vals['excludeVariantIds'];
      }
      if (isset($vals['autocompleteQuery'])) {
        $this->autocompleteQuery = $vals['autocompleteQuery'];
      }
      if (isset($vals['searchChoiceId'])) {
        $this->searchChoiceId = $vals['searchChoiceId'];
      }
      if (isset($vals['searchQuery'])) {
        $this->searchQuery = $vals['searchQuery'];
      }
      if (isset($vals['includeVariantIds'])) {
        $this->includeVariantIds = $vals['includeVariantIds'];
      }
      if (isset($vals['propertyQueries'])) {
        $this->propertyQueries = $vals['propertyQueries'];
      }
    }
  }

  public function getName() {
    return 'AutocompleteRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 11:
          if ($ftype == TType::STRUCT) {
            $this->userRecord = new \com\boxalino\p13n\api\thrift\UserRecord();
            $xfer += $this->userRecord->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 21:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->scope);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 31:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->choiceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 41:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->profileId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 51:
          if ($ftype == TType::STRUCT) {
            $this->requestContext = new \com\boxalino\p13n\api\thrift\RequestContext();
            $xfer += $this->requestContext->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 61:
          if ($ftype == TType::SET) {
            $this->excludeVariantIds = array();
            $_size223 = 0;
            $_etype226 = 0;
            $xfer += $input->readSetBegin($_etype226, $_size223);
            for ($_i227 = 0; $_i227 < $_size223; ++$_i227)
            {
              $elem228 = null;
              $xfer += $input->readString($elem228);
              if (is_scalar($elem228)) {
                $this->excludeVariantIds[$elem228] = true;
              } else {
                $this->excludeVariantIds []= $elem228;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 71:
          if ($ftype == TType::STRUCT) {
            $this->autocompleteQuery = new \com\boxalino\p13n\api\thrift\AutocompleteQuery();
            $xfer += $this->autocompleteQuery->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 81:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->searchChoiceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 91:
          if ($ftype == TType::STRUCT) {
            $this->searchQuery = new \com\boxalino\p13n\api\thrift\SimpleSearchQuery();
            $xfer += $this->searchQuery->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 101:
          if ($ftype == TType::SET) {
            $this->includeVariantIds = array();
            $_size229 = 0;
            $_etype232 = 0;
            $xfer += $input->readSetBegin($_etype232, $_size229);
            for ($_i233 = 0; $_i233 < $_size229; ++$_i233)
            {
              $elem234 = null;
              $xfer += $input->readString($elem234);
              if (is_scalar($elem234)) {
                $this->includeVariantIds[$elem234] = true;
              } else {
                $this->includeVariantIds []= $elem234;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 110:
          if ($ftype == TType::LST) {
            $this->propertyQueries = array();
            $_size235 = 0;
            $_etype238 = 0;
            $xfer += $input->readListBegin($_etype238, $_size235);
            for ($_i239 = 0; $_i239 < $_size235; ++$_i239)
            {
              $elem240 = null;
              $elem240 = new \com\boxalino\p13n\api\thrift\PropertyQuery();
              $xfer += $elem240->read($input);
              $this->propertyQueries []= $elem240;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AutocompleteRequest');
    if ($this->userRecord !== null) {
      if (!is_object($this->userRecord)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userRecord', TType::STRUCT, 11);
      $xfer += $this->userRecord->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->scope !== null) {
      $xfer += $output->writeFieldBegin('scope', TType::STRING, 21);
      $xfer += $output->writeString($this->scope);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->choiceId !== null) {
      $xfer += $output->writeFieldBegin('choiceId', TType::STRING, 31);
      $xfer += $output->writeString($this->choiceId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->profileId !== null) {
      $xfer += $output->writeFieldBegin('profileId', TType::STRING, 41);
      $xfer += $output->writeString($this->profileId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->requestContext !== null) {
      if (!is_object($this->requestContext)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('requestContext', TType::STRUCT, 51);
      $xfer += $this->requestContext->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->excludeVariantIds !== null) {
      if (!is_array($this->excludeVariantIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('excludeVariantIds', TType::SET, 61);
      {
        $output->writeSetBegin(TType::STRING, count($this->excludeVariantIds));
        {
          foreach ($this->excludeVariantIds as $iter241 => $iter242)
          {
            if (is_scalar($iter242)) {
            $xfer += $output->writeString($iter241);
            } else {
            $xfer += $output->writeString($iter242);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->autocompleteQuery !== null) {
      if (!is_object($this->autocompleteQuery)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('autocompleteQuery', TType::STRUCT, 71);
      $xfer += $this->autocompleteQuery->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->searchChoiceId !== null) {
      $xfer += $output->writeFieldBegin('searchChoiceId', TType::STRING, 81);
      $xfer += $output->writeString($this->searchChoiceId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->searchQuery !== null) {
      if (!is_object($this->searchQuery)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('searchQuery', TType::STRUCT, 91);
      $xfer += $this->searchQuery->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->includeVariantIds !== null) {
      if (!is_array($this->includeVariantIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('includeVariantIds', TType::SET, 101);
      {
        $output->writeSetBegin(TType::STRING, count($this->includeVariantIds));
        {
          foreach ($this->includeVariantIds as $iter243 => $iter244)
          {
            if (is_scalar($iter244)) {
            $xfer += $output->writeString($iter243);
            } else {
            $xfer += $output->writeString($iter244);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->propertyQueries !== null) {
      if (!is_array($this->propertyQueries)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('propertyQueries', TType::LST, 110);
      {
        $output->writeListBegin(TType::STRUCT, count($this->propertyQueries));
        {
          foreach ($this->propertyQueries as $iter245)
          {
            $xfer += $iter245->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PropertyQuery {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;
  /**
   * @var int
   */
  public $hitCount = null;
  /**
   * @var bool
   */
  public $evaluateTotal = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        11 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        21 => array(
          'var' => 'hitCount',
          'type' => TType::I32,
          ),
        31 => array(
          'var' => 'evaluateTotal',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['hitCount'])) {
        $this->hitCount = $vals['hitCount'];
      }
      if (isset($vals['evaluateTotal'])) {
        $this->evaluateTotal = $vals['evaluateTotal'];
      }
    }
  }

  public function getName() {
    return 'PropertyQuery';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 21:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->hitCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 31:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->evaluateTotal);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PropertyQuery');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 11);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hitCount !== null) {
      $xfer += $output->writeFieldBegin('hitCount', TType::I32, 21);
      $xfer += $output->writeI32($this->hitCount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->evaluateTotal !== null) {
      $xfer += $output->writeFieldBegin('evaluateTotal', TType::BOOL, 31);
      $xfer += $output->writeBool($this->evaluateTotal);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PropertyResult {
  static $_TSPEC;

  /**
   * @var \com\boxalino\p13n\api\thrift\PropertyHit[]
   */
  public $hits = null;
  /**
   * @var string
   */
  public $name = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        11 => array(
          'var' => 'hits',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\PropertyHit',
            ),
          ),
        21 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['hits'])) {
        $this->hits = $vals['hits'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
    }
  }

  public function getName() {
    return 'PropertyResult';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 11:
          if ($ftype == TType::LST) {
            $this->hits = array();
            $_size246 = 0;
            $_etype249 = 0;
            $xfer += $input->readListBegin($_etype249, $_size246);
            for ($_i250 = 0; $_i250 < $_size246; ++$_i250)
            {
              $elem251 = null;
              $elem251 = new \com\boxalino\p13n\api\thrift\PropertyHit();
              $xfer += $elem251->read($input);
              $this->hits []= $elem251;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 21:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PropertyResult');
    if ($this->hits !== null) {
      if (!is_array($this->hits)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hits', TType::LST, 11);
      {
        $output->writeListBegin(TType::STRUCT, count($this->hits));
        {
          foreach ($this->hits as $iter252)
          {
            $xfer += $iter252->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 21);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PropertyHit {
  static $_TSPEC;

  /**
   * @var string
   */
  public $value = null;
  /**
   * @var string
   */
  public $label = null;
  /**
   * @var int
   */
  public $totalHitCount = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        11 => array(
          'var' => 'value',
          'type' => TType::STRING,
          ),
        21 => array(
          'var' => 'label',
          'type' => TType::STRING,
          ),
        31 => array(
          'var' => 'totalHitCount',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
      if (isset($vals['label'])) {
        $this->label = $vals['label'];
      }
      if (isset($vals['totalHitCount'])) {
        $this->totalHitCount = $vals['totalHitCount'];
      }
    }
  }

  public function getName() {
    return 'PropertyHit';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 21:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->label);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 31:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->totalHitCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PropertyHit');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 11);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->label !== null) {
      $xfer += $output->writeFieldBegin('label', TType::STRING, 21);
      $xfer += $output->writeString($this->label);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->totalHitCount !== null) {
      $xfer += $output->writeFieldBegin('totalHitCount', TType::I64, 31);
      $xfer += $output->writeI64($this->totalHitCount);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AutocompleteResponse {
  static $_TSPEC;

  /**
   * @var \com\boxalino\p13n\api\thrift\AutocompleteHit[]
   */
  public $hits = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\SearchResult
   */
  public $prefixSearchResult = null;
  /**
   * @var \com\boxalino\p13n\api\thrift\PropertyResult[]
   */
  public $propertyResults = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        11 => array(
          'var' => 'hits',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\AutocompleteHit',
            ),
          ),
        21 => array(
          'var' => 'prefixSearchResult',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\p13n\api\thrift\SearchResult',
          ),
        31 => array(
          'var' => 'propertyResults',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\PropertyResult',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['hits'])) {
        $this->hits = $vals['hits'];
      }
      if (isset($vals['prefixSearchResult'])) {
        $this->prefixSearchResult = $vals['prefixSearchResult'];
      }
      if (isset($vals['propertyResults'])) {
        $this->propertyResults = $vals['propertyResults'];
      }
    }
  }

  public function getName() {
    return 'AutocompleteResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 11:
          if ($ftype == TType::LST) {
            $this->hits = array();
            $_size253 = 0;
            $_etype256 = 0;
            $xfer += $input->readListBegin($_etype256, $_size253);
            for ($_i257 = 0; $_i257 < $_size253; ++$_i257)
            {
              $elem258 = null;
              $elem258 = new \com\boxalino\p13n\api\thrift\AutocompleteHit();
              $xfer += $elem258->read($input);
              $this->hits []= $elem258;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 21:
          if ($ftype == TType::STRUCT) {
            $this->prefixSearchResult = new \com\boxalino\p13n\api\thrift\SearchResult();
            $xfer += $this->prefixSearchResult->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 31:
          if ($ftype == TType::LST) {
            $this->propertyResults = array();
            $_size259 = 0;
            $_etype262 = 0;
            $xfer += $input->readListBegin($_etype262, $_size259);
            for ($_i263 = 0; $_i263 < $_size259; ++$_i263)
            {
              $elem264 = null;
              $elem264 = new \com\boxalino\p13n\api\thrift\PropertyResult();
              $xfer += $elem264->read($input);
              $this->propertyResults []= $elem264;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AutocompleteResponse');
    if ($this->hits !== null) {
      if (!is_array($this->hits)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('hits', TType::LST, 11);
      {
        $output->writeListBegin(TType::STRUCT, count($this->hits));
        {
          foreach ($this->hits as $iter265)
          {
            $xfer += $iter265->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->prefixSearchResult !== null) {
      if (!is_object($this->prefixSearchResult)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('prefixSearchResult', TType::STRUCT, 21);
      $xfer += $this->prefixSearchResult->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->propertyResults !== null) {
      if (!is_array($this->propertyResults)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('propertyResults', TType::LST, 31);
      {
        $output->writeListBegin(TType::STRUCT, count($this->propertyResults));
        {
          foreach ($this->propertyResults as $iter266)
          {
            $xfer += $iter266->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AutocompleteRequestBundle {
  static $_TSPEC;

  /**
   * @var \com\boxalino\p13n\api\thrift\AutocompleteRequest[]
   */
  public $requests = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        11 => array(
          'var' => 'requests',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\AutocompleteRequest',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['requests'])) {
        $this->requests = $vals['requests'];
      }
    }
  }

  public function getName() {
    return 'AutocompleteRequestBundle';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 11:
          if ($ftype == TType::LST) {
            $this->requests = array();
            $_size267 = 0;
            $_etype270 = 0;
            $xfer += $input->readListBegin($_etype270, $_size267);
            for ($_i271 = 0; $_i271 < $_size267; ++$_i271)
            {
              $elem272 = null;
              $elem272 = new \com\boxalino\p13n\api\thrift\AutocompleteRequest();
              $xfer += $elem272->read($input);
              $this->requests []= $elem272;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AutocompleteRequestBundle');
    if ($this->requests !== null) {
      if (!is_array($this->requests)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('requests', TType::LST, 11);
      {
        $output->writeListBegin(TType::STRUCT, count($this->requests));
        {
          foreach ($this->requests as $iter273)
          {
            $xfer += $iter273->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AutocompleteResponseBundle {
  static $_TSPEC;

  /**
   * @var \com\boxalino\p13n\api\thrift\AutocompleteResponse[]
   */
  public $responses = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        11 => array(
          'var' => 'responses',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\com\boxalino\p13n\api\thrift\AutocompleteResponse',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['responses'])) {
        $this->responses = $vals['responses'];
      }
    }
  }

  public function getName() {
    return 'AutocompleteResponseBundle';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 11:
          if ($ftype == TType::LST) {
            $this->responses = array();
            $_size274 = 0;
            $_etype277 = 0;
            $xfer += $input->readListBegin($_etype277, $_size274);
            for ($_i278 = 0; $_i278 < $_size274; ++$_i278)
            {
              $elem279 = null;
              $elem279 = new \com\boxalino\p13n\api\thrift\AutocompleteResponse();
              $xfer += $elem279->read($input);
              $this->responses []= $elem279;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AutocompleteResponseBundle');
    if ($this->responses !== null) {
      if (!is_array($this->responses)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('responses', TType::LST, 11);
      {
        $output->writeListBegin(TType::STRUCT, count($this->responses));
        {
          foreach ($this->responses as $iter280)
          {
            $xfer += $iter280->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Request object for changing the choice, that is changing possible variants
 * or their random distribution
 */
class ChoiceUpdateRequest {
  static $_TSPEC;

  /**
   * user record identifying the client
   * 
   * @var \com\boxalino\p13n\api\thrift\UserRecord
   */
  public $userRecord = null;
  /**
   * Identifier of the choice to be changed. If it is not given, a new choice will be created
   * 
   * @var string
   */
  public $choiceId = null;
  /**
   * Map containing variant identifier and corresponding positive integer weight.
   * If for a choice there is no learned rule which can be applied, weights of
   * variants will be used for variants random distribution.
   * Higher weight makes corresponding variant more probable.
   * 
   * @var array
   */
  public $variantIds = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        11 => array(
          'var' => 'userRecord',
          'type' => TType::STRUCT,
          'class' => '\com\boxalino\p13n\api\thrift\UserRecord',
          ),
        21 => array(
          'var' => 'choiceId',
          'type' => TType::STRING,
          ),
        31 => array(
          'var' => 'variantIds',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['userRecord'])) {
        $this->userRecord = $vals['userRecord'];
      }
      if (isset($vals['choiceId'])) {
        $this->choiceId = $vals['choiceId'];
      }
      if (isset($vals['variantIds'])) {
        $this->variantIds = $vals['variantIds'];
      }
    }
  }

  public function getName() {
    return 'ChoiceUpdateRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 11:
          if ($ftype == TType::STRUCT) {
            $this->userRecord = new \com\boxalino\p13n\api\thrift\UserRecord();
            $xfer += $this->userRecord->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 21:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->choiceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 31:
          if ($ftype == TType::MAP) {
            $this->variantIds = array();
            $_size281 = 0;
            $_ktype282 = 0;
            $_vtype283 = 0;
            $xfer += $input->readMapBegin($_ktype282, $_vtype283, $_size281);
            for ($_i285 = 0; $_i285 < $_size281; ++$_i285)
            {
              $key286 = '';
              $val287 = 0;
              $xfer += $input->readString($key286);
              $xfer += $input->readI32($val287);
              $this->variantIds[$key286] = $val287;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ChoiceUpdateRequest');
    if ($this->userRecord !== null) {
      if (!is_object($this->userRecord)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userRecord', TType::STRUCT, 11);
      $xfer += $this->userRecord->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->choiceId !== null) {
      $xfer += $output->writeFieldBegin('choiceId', TType::STRING, 21);
      $xfer += $output->writeString($this->choiceId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->variantIds !== null) {
      if (!is_array($this->variantIds)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('variantIds', TType::MAP, 31);
      {
        $output->writeMapBegin(TType::STRING, TType::I32, count($this->variantIds));
        {
          foreach ($this->variantIds as $kiter288 => $viter289)
          {
            $xfer += $output->writeString($kiter288);
            $xfer += $output->writeI32($viter289);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Server response for one ChoiceUpdateRequest
 */
class ChoiceUpdateResponse {
  static $_TSPEC;

  /**
   * Identifier of the changed choice. If no id is given in corresponding
   * ChoiceUpdateRequest, new choice (and new id) will be created and retuned.
   * 
   * @var string
   */
  public $choiceId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        11 => array(
          'var' => 'choiceId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['choiceId'])) {
        $this->choiceId = $vals['choiceId'];
      }
    }
  }

  public function getName() {
    return 'ChoiceUpdateResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->choiceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ChoiceUpdateResponse');
    if ($this->choiceId !== null) {
      $xfer += $output->writeFieldBegin('choiceId', TType::STRING, 11);
      $xfer += $output->writeString($this->choiceId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class P13nServiceException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'P13nServiceException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('P13nServiceException');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}


